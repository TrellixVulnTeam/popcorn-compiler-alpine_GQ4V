#!/usr/bin/python3

import os
import sys
import platform
import argparse
import subprocess
import datetime

import perf-scrape
import htm-config

###############################################################################
# Initialization
###############################################################################

def parseArguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # TODO help text

    config = parser.add_argument_group("Configuration")
    config.add_argument("-binary", type=str, required=True,
        help="Name of binary generated by build command",
        dest="binary")
    config.add_argument("-build-cmd", type=str, required=True,
        help="Command to build the binary",
        dest="buildCmd")
    config.add_argument("-run-cmd", type=str, required=True,
        help="Command to run the architecture-specific perf profiler",
        dest="runCmd")
    config.add_argument("-clean-cmd", type=str,
        help="Command to clean the build",
        default="make clean",
        dest="cleanCmd")
    config.add_argument("-max-iter", type=int,
        help="Maximum number of iterations to explore configuration",
        default=30,
        dest="iters")
    config.add_argument("-target-time", type=float, required=True,
        help="Time to run uninstrumented version of the application (used for " \
             "determining when to stop)",
        dest="targetTime")
    config.add_argument("-stop-thresh", type=int,
        help="Percent of target time at which stop configuration exploration",
        default=2,
        dest="stopThresh")a
    config.add_argument("-perf", type=str, help="Which version of perf to use",
        default="~/perf/perf",
        dest="perf")

    return parser.parse_args()

def writeReadme(readme):
    readme.write("Running:\n  Results for binary: {}\n".format(args.binary))
    readme.write("  Build command: {}\n".format(args.buildCmd))
    readme.write("  Run command: {}\n".format(args.runCmd))
    readme.write("  Clean command: {}\n\n".format(args.cleanCmd))

def initialize(args):
    now = datetime.datetime.now()
    results = "htm-overhead-{}-{}-{}-{}-{}".format(
        now.hour, now.minute, now.day, now.month, now.year)
    if os.path.exists(results):
        print("Could not create perf output folder '{}'".format(results))
        sys.exit(1)
    os.makedirs(results)
    with open(results + "/README", 'w') as readme:
        writeReadme(readme)
    return results

###############################################################################
# Generating & running the binary
###############################################################################

# Run the clean command to remove previous builds.
def cleanBuild(cleanCmd):
    try:
        args = cleanCmd.strip().split()
        rv = subprocess.check_call(args, stderr=subprocess.STDOUT)
    except Exception as e:
        print("Could not clean in preparation for building ({})!".format(e))
        sys.exit(1)
    else:
        if rv != 0:
            print("ERROR: could not clean up previous installation!")
            sys.exit(1)

# Run the build command to generate a binary with a given configuration.
def buildBinary(buildCmd, binary, capThresh, startThresh, \
                retThresh, funcThresh):
    def funcThreshArgs(funcConfig):
        conf = ""
        for func in funcConfig:
            conf += " -mllvm -func-cap={},{}".format(func, funcConfig[func])
        return conf

    try:
        args = buildCmd.strip().split()
        args.append("CAP_THRESH={}".format(capThresh))
        args.append("START_THRESH={}".format(startThresh))
        args.append("RET_THRESH={}".format(retThresh))
        args.append("OTHER=\"{}\"".format(funcThreshArgs(funcThresh)))
        rv = subprocess.check_call(args, stderr=subprocess.STDOUT)
    except Exception as e:
        print("Could not build the binary:\n{}".format(e))
        sys.exit(1)
    else:
        if rv != 0:
            print("Could not build the binary!")
            sys.exit(1)

    assert os.path.isfile(binary), \
           "Binary {} does not exist after build!".format(binary)

def runBinary(it, outputFolder, runCmd, binary):
    try:
        args = runCmd.strip().split()
        rv = subprocess.check_call(args, stderr=subprocess.STDOUT)
    except Exception as e:
        print("Could not run the binary ({})!".format(e))
        sys.exit(1)

    # The run command should have generated a counters file (*.log) and a
    # sampling file (*.data)
    statOutput = "{}.log".format(binary)
    recordOutput = "{}.data".format(binary)
    assert os.path.isfile(statOutput), \
           "perf-stat output {} does not exist after run!".format(statOutput)
    assert os.path.isfile(recordOutput), \
           "perf-record output {} does not exist after run!".format(recordOutput)
    statDest = outputFolder + '/' + statOutput[statOutput.rfind('/'):]
    recordDest = outputFolder + '/' + recordOutput[recordOutput.rfind('/'):]
    os.rename(statOutput, statOutput)
    os.rename(recordOutput, recordOutput)
    return statDest, recordDest

def runConfiguration(args, iteration, outputFolder, capThresh, \
                     startThresh, retThresh, funcThresh):
    # Make an output folder for the current iteration.
    iterDir = outputFolder + "/" + str(iteration)
    os.makedirs(iterDir)

    # Clean/build/run the current configuration
    cleanBuild(args.cleanCmd)
    buildBinary(args.buildCmd, args.binary, capThresh, \
                startThresh, retThresh, funcThresh)
    return runBinary(it, iterDir, args.runCmd, args.binary)

###############################################################################
# Driver
###############################################################################

if __name__ == "__main__":
    args = parseArguments()
    results = initialize(args)
    arch = platform.machine()
    drake = ConfigureHTM(arch, args.stopThresh, args.targetTime, results)
    curIter = 0

    while drake.keepGoing:
        if curIter > args.iters: break
        else: curIter += 1

        capThresh, startThresh, \
        retThresh, funcThresh = drake.getConfiguration()
        stat, record = runConfiguration(args, curIter, results, capThresh \
                                        startThresh, retThresh, funcThresh)

        time, ctrs = scrapePerfStat(stat)
        numSamples, eventCount, samples = scrapePerfReport(args.perf, record)

        drake.analyze(time, ctrs, samples)

    drake.writeBest()

