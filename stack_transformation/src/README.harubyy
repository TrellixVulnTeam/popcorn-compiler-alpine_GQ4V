ABBRV. Table
---------------
ST         : Stack Transformation
ENV. VAR.  : Environment Variables
ARCH.      : Architecture
RW_CTX     : Rewriting context
RA         : Return Address
---------------

############################################################### data.c:
APIs for accessing frame-specific data, i.e. live values, return address,
and saved frame pointer.

Also carries values from source to destination call site.


**** Includes:
data.h
unwind.h


**** Contents:
Implements data.h
Uses unwind.h

File-specific implementation:
static inline void* get_val_loc(rewrite_context ctx,uint8_t type, uint16_t regnum,int32_t offset_or_constant,int act);
static const void* get_src_loc(rewrite_context ctx, const call_site_value* val,int act);
static void* get_dest_loc(rewrite_context ctx,const call_site_value* val,int act);
static void* callee_saved_loc(rewrite_context ctx,uint16_t regnum,int act);
uint64_t* get_savedfbp_loc(rewrite_context ctx);
static inline void* get_val_loc(rewrite_context ctx, uint8_t type,uint16_t regnum, int32_t offset_or_constant, int act);
static const void* get_src_loc(rewrite_context ctx, const call_site_value* val, int act);
static void* get_dest_loc(rewrite_context ctx, const call_site_value* val,int act);
void put_val(rewrite_context src, const call_site_value* src_val,rewrite_context dest,const call_site_value* dest_val);
void put_val_arch(rewrite_context ctx, const arch_const_value* val);
void put_val_data(rewrite_context ctx, const call_site_value* val,int act,uint64_t data);
void* points_to_stack(const rewrite_context ctx,const call_site_value* val);
ivoid* points_to_data(const rewrite_context src, const call_site_value* src_val, const rewrite_context dest, const call_site_value* dest_val, void* src_ptr);
void set_return_address(rewrite_context ctx, void* retaddr);
saved_addr = get_register_save_loc(ctx, &ctx->acts[act], regnum);


############################################################### unwind.c:
Implements the logic necessary to unwind/un-unwind stack frame activations

**** Includes:
unwind.h

**** Contents:
void setup_frame_info(rewrite_context ctx);
void setup_frame_info_funcentry(rewrite_context ctx);
void pop_frame(rewrite_context ctx);
void pop_frame_funcentry(rewrite_context ctx);
void* get_register_save_loc(rewrite_context ctx, activation* act, uint16_t reg);
void free_activation(st_handle handle, activation* act);

############################################################### init.c:
Main stack transformation functions. In general these functions are used 
to drive stack transformation.
Implements the initial setup and teardown functions necessary to do
the stack transaformation, initializes the logger`

**** st_init does the following:
Initialize libelf data 
Get architecture-specific information 
Read unwinding addresses 
Read unwinding information 
Read call site metadata 
Read live value location records 
Read architecture-specific live value location records 
Get architecture-specific register operations & stack properties


**** Includes:
stack_transform.h"
unwind.h"
util.h

**** Contents:
st_handle st_init(const char* fn):
void st_destroy(st_handle handle):

############################################################### util.c:
Functions to reach the meta-data

**** Includes:
stack_transform.h
definitions.h
arch_regs.h
util.h

**** Contents:
regops_t get_regops(uint16_t arch)
properties_t get_properties(uint16_t arch)
Elf_Scn* get_section(Elf* e, const char* sec)
int64_t get_num_entries(Elf* e, const char* sec)
const void* get_section_data(Elf* e, const char* sec)
bool get_site_by_addr(st_handle handle, void* ret_addr, call_site* cs)
bool get_site_by_id(st_handle handle, uint64_t csid, call_site* cs)
bool get_unwind_offset_by_addr(st_handle handle, void* addr, unwind_addr* meta)


############################################################### rewrite.c:
Implements the main rewriting logic for stack transformation. Unwinds all source
frames and finds live values, calculates sp and fbp, applies fixups where necessary
and transforms the stack for the destination architecture.

**** Includes:
stack_transform.h
data.h
unwind.h
util.h


**** Contents:
static __thread struct rewrite_context src_ctx, dest_ctx;
static rewrite_context init_src_context(st_handle handle,void* regset, void* sp_base);
static rewrite_context init_dest_context(st_handle handle,void* regset, void* sp_base, void* pc);
static void init_data_pools(rewrite_context ctx);
static void free_context(rewrite_context ctx);
static void free_data_pools(rewrite_context ctx);
static void unwind_and_size(rewrite_context src, rewrite_context dest);
static bool rewrite_val(rewrite_context src, const call_site_value* val_src, rewrite_context dest, const call_site_value* val_dest);
static inline void fixup_local_pointers(rewrite_context src, rewrite_context dest)
static void rewrite_frame(rewrite_context src, rewrite_context dest);
int st_rewrite_stack(st_handle handle_src, void* regset_src, void* sp_base_src, st_handle handle_dest, void* regset_dest, void* sp_base_dest);


############################################################### list.c:
Implements a linked list with only forward traversal and there's no need to support sorting
This linked list holds the fixups

**** Contents:


############################################################### userspace.c:
User-space stack rewriting implementation. Includes all APIs to boostrap
and re-write the stack for a currently-executing program, all in userspace.

It has functions to:
 -- Touch stack pages up to the OS-defined stack size limit, 
    so that the OS allocates them and we can divide the stack in half for rewriting.  
    Also, calculate stack bounds for main thread
 -- Prepare the stack by setting bounds and sp & fbp
 -- Read stack information about main thread & cloned threads
 -- Rewrite from source to destination stack.  Logically, divides 8MB stack in
    half, detects which half we're currently using and rewrite to the other.


**** Includes:
stack_transform.h
definitions.h
util.h
arch/x86_64/regs.h
arch/aarch64/regs.h

**** Contents:
static st_handle aarch64_handle = NULL;
static st_handle x86_64_handle = NULL;
#if _TLS_IMPL == COMPILER_TLS
static __thread stack_bounds bounds = { .high = NULL, .low = NULL };
#else /* PTHREAD_TLS */
static pthread_key_t stack_bounds_key = 0;
#endif

static bool prep_stack(void);
static bool get_main_stack(stack_bounds* bounds);
static bool get_thread_stack(stack_bounds* bounds);
static int userspace_rewrite_internal(void* sp,void* regs,void* dest_regs,st_handle handle_a,st_handle handle_b);
int st_userspace_rewrite(void* sp, void* regs,void* dest_regs);
int st_userspace_rewrite_aarch64(void* sp, struct regset_aarch64* regs, struct regset_aarch64* dest_regs);
int st_userspace_rewrite_x86_64(void* sp, struct regset_x86_64* regs, struct regset_x86_64* dest_regs);

extern const char *__progname;
char* __attribute__((weak)) aarch64_fn = NULL;
static bool alloc_aarch64_fn = false;
char* __attribute__((weak)) x86_64_fn = NULL;
static bool alloc_x86_64_fn = false;

void __st_userspace_ctor(void);
void __st_userspace_dtor(void);



############################################################### arch/x86_64/properties.c:
x86-64 stack properties

**** Includes:
definitions.h
arch/x86_64/regs.h

**** Contents:
#define X86_64_RA_OFFSET -0x8
#define X86_64_SAVED_FBP_OFFSET -0x10
#define X86_64_CFA_OFFSET 0x10
#define X86_64_CFA_OFFSET_FUNCENTRY 0x8
#define X86_64_STACK_ALIGNMENT 0x10
#define X86_64_SP_FIXUP 0x8
static const uint16_t callee_saved_x86_64[] = { RBX, RBP, R12, R13, R14, R15, RIP };
static const uint16_t callee_saved_size_x86_64[] = { 8, 8, 8, 8, 8, 8, 8 };
const struct properties_t properties_x86_64 = {
.sp_needs_align = true,
.num_callee_saved = sizeof(callee_saved_x86_64) / sizeof(uint16_t),
.callee_saved = callee_saved_x86_64,
.callee_saved_size = callee_saved_size_x86_64,
.ra_offset = X86_64_RA_OFFSET,
.savedfbp_offset = X86_64_SAVED_FBP_OFFSET,
.cfa_offset = X86_64_CFA_OFFSET,
.cfa_offset_funcentry = X86_64_CFA_OFFSET_FUNCENTRY,

.align_sp = align_sp_x86_64,
.is_callee_saved = is_callee_saved_x86_64,
.callee_reg_size = callee_reg_size_x86_64
};


static void* align_sp_x86_64(void* sp);
static bool is_callee_saved_x86_64(uint16_t reg);
static uint16_t callee_reg_size_x86_64(uint16_t reg);
static void* align_sp_x86_64(void* sp);
static bool is_callee_saved_x86_64(uint16_t reg);
static uint16_t callee_reg_size_x86_64(uint16_t reg);

############################################################### arch/x86_64/regs.c:
regset_obj_x86_64:
Internal definition of x86-64 object, contains x86-64 registers in addition
to common fields & functions.

struct regops_t regs_x86_64:
x86-64 register operations (externally visible), used to construct new
objects.
 

**** Includes:
definitions.h
arch/x86_64/regs.h

**** Contents:
#define X86_64_NUM_REGS 67

static regset_t regset_default_x86_64(void);
static regset_t regset_init_x86_64(const void* regs);
static void regset_free_x86_64(regset_t regset);
static void regset_clone_x86_64(const_regset_t src, regset_t dest);
static void regset_copyin_x86_64(regset_t regset, const void* regs);
static void regset_copyout_x86_64(const_regset_t regset, void* regs);

static void* pc_x86_64(const_regset_t regset);
static void* sp_x86_64(const_regset_t regset);
static void* fbp_x86_64(const_regset_t regset);
static void* ra_reg_x86_64(const_regset_t regset);

static void set_pc_x86_64(regset_t regset, void* pc);
static void set_sp_x86_64(regset_t regset, void* sp);
static void set_fbp_x86_64(regset_t regset, void* fbp);
static void set_ra_reg_x86_64(regset_t regset, void* ra);

static uint16_t reg_size_x86_64(uint16_t reg);
static void* reg_x86_64(regset_t regset, uint16_t reg);


typedef struct regset_obj_x86_64
{
struct regset_t common;
struct regset_x86_64 regs;
} regset_obj_x86_64;

const struct regops_t regs_x86_64 = {
.num_regs = X86_64_NUM_REGS,
.has_ra_reg = false,
.regset_size = sizeof(regset_obj_x86_64),

.regset_default = regset_default_x86_64,
.regset_init = regset_init_x86_64,
.regset_free = regset_free_x86_64,
.regset_clone = regset_clone_x86_64,
.regset_copyin = regset_copyin_x86_64,
.regset_copyout = regset_copyout_x86_64,

.pc = pc_x86_64,
.sp = sp_x86_64,
.fbp = fbp_x86_64,
.ra_reg = ra_reg_x86_64,

.set_pc = set_pc_x86_64,
.set_sp = set_sp_x86_64,
.set_fbp = set_fbp_x86_64,
.set_ra_reg = set_ra_reg_x86_64,

.reg_size = reg_size_x86_64,
.reg = reg_x86_64,
};


############################################################### arch/aarch64/properties.c, arch/aarch64/regs.c:
Analogous to x86_64



