Index: lib/Target/PowerPC/CMakeLists.txt
===================================================================
--- lib/Target/PowerPC/CMakeLists.txt  (revision 277823)
+++ lib/Target/PowerPC/CMakeLists.txt  (working copy)
@@ -37,6 +37,7 @@
   PPCVSXCopy.cpp
   PPCVSXFMAMutate.cpp
   PPCVSXSwapRemoval.cpp
+  PowerPC64Values.cpp
   )
 
 add_subdirectory(AsmParser)
Index: lib/Target/PowerPC/PowerPC64Values.cpp
===================================================================
--- lib/Target/PowerPC/PowerPC64Values.cpp  (nonexistent)
+++ lib/Target/PowerPC/PowerPC64Values.cpp  (working copy)
@@ -0,0 +1,132 @@
+//===- PowerPC64TargetValues.cpp - PowerPC64 specific value generator -===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "PowerPC64Values.h"
+#include "PPC.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Target/TargetInstrInfo.h"
+#include "llvm/Target/TargetSubtargetInfo.h"
+
+#define DEBUG_TYPE "stacktransform"
+
+using namespace llvm;
+
+// Make types in MachineGeneratedVal more accessible
+typedef MachineGeneratedVal::ValueGenInst ValueGenInst;
+typedef MachineGeneratedVal::ValueGenInst::InstType InstType;
+typedef MachineGeneratedVal::ValueGenInstPtr ValueGenInstPtr;
+typedef MachineGeneratedVal::ValueGenInstList ValueGenInstList;
+
+template <InstType T>
+using RegInstruction = MachineGeneratedVal::RegInstruction<T>;
+template <InstType T>
+using ImmInstruction = MachineGeneratedVal::ImmInstruction<T>;
+template <InstType T>
+using PseudoInstruction = MachineGeneratedVal::PseudoInstruction<T>;
+
+void PowerPC64Values::genADDInstructions(const MachineInstr *MI,
+                                       ValueGenInstList &IL) const {
+  int Index;
+
+  /*switch(MI->getOpcode()) {
+  case PowerPC64::ADDXri:
+    if(MI->getOperand(1).isFI()) {
+      Index = MI->getOperand(1).getIndex();
+      IL.push_back(ValueGenInstPtr(
+        new PseudoInstruction<InstType::StackSlot>(Index, InstType::Set)));
+      assert(MI->getOperand(2).isImm() && MI->getOperand(2).getImm() == 0);
+      assert(MI->getOperand(3).isImm() && MI->getOperand(3).getImm() == 0);
+    }
+    break;
+  default:
+    llvm_unreachable("Unhandled ADD machine instruction");
+    break;
+  }*/
+}
+
+void PowerPC64Values::genBitfieldInstructions(const MachineInstr *MI,
+                                            ValueGenInstList &IL) const {
+  int64_t R, S;
+  unsigned Size = 8, Bits = 64;
+  const uint64_t Mask = UINT64_MAX;
+
+  /*switch(MI->getOpcode()) {
+  case PowerPC64::UBFMXri:
+    // TODO ensure this is correct
+    assert(MI->getOperand(1).isReg() && MI->getOperand(2).isImm() &&
+           MI->getOperand(3).isImm());
+    IL.push_back(ValueGenInstPtr(
+      new RegInstruction<InstType::Set>(MI->getOperand(1).getReg())));
+    R = MI->getOperand(2).getImm();
+    S = MI->getOperand(3).getImm();
+    if(S >= R) {
+      IL.push_back(ValueGenInstPtr(
+        new ImmInstruction<InstType::RightShiftLog>(Size, R)));
+      IL.push_back(ValueGenInstPtr(
+        new ImmInstruction<InstType::Mask>(Size, ~(Mask << (S - R + 1)))));
+    }
+    else {
+      IL.push_back(ValueGenInstPtr(
+        new ImmInstruction<InstType::Mask>(Size, ~(Mask << (S + 1)))));
+      IL.push_back(ValueGenInstPtr(
+        new ImmInstruction<InstType::LeftShift>(Size, Bits - R)));
+    }
+    break;
+  }*/
+}
+
+MachineLiveValPtr PowerPC64Values::getMachineValue(const MachineInstr *MI) const {
+  MachineLiveVal* Val = nullptr;
+  const MachineOperand *MO;
+  const TargetInstrInfo *TII;
+  ValueGenInstList IL;
+
+  return nullptr;
+ /* switch(MI->getOpcode()) {
+  case PowerPC64::MOVaddr:
+  case PowerPC64::ADRP:
+    MO = &MI->getOperand(1);
+    if(MO->isCPI()) {
+      IL.push_back(ValueGenInstPtr(
+        new PseudoInstruction<InstType::ConstantPool>(MO->getIndex(),
+                                                      InstType::Set)));
+      Val = new MachineGeneratedVal(IL, MI);
+    }
+    else {
+      assert((MO->isGlobal() || MO->isSymbol() || MO->isMCSymbol()) &&
+             "Invalid operand for address generation");
+      if(MO->isGlobal())
+        Val = new MachineReference(MO->getGlobal()->getName(), MI);
+      else if(MO->isSymbol())
+        Val = new MachineReference(MO->getSymbolName(), MI);
+      else if(MO->isMCSymbol())
+        Val = new MachineReference(MO->getMCSymbol()->getName(), MI);
+    }
+    break;
+  case PowerPC64::ADDXri:
+    genADDInstructions(MI, IL);
+    if(IL.size()) Val = new MachineGeneratedVal(IL, MI);
+    break;
+  case PowerPC64::UBFMXri:
+    genBitfieldInstructions(MI, IL);
+    if(IL.size()) Val = new MachineGeneratedVal(IL, MI);
+    break;
+  default:
+    TII =  MI->getParent()->getParent()->getSubtarget().getInstrInfo();
+    DEBUG(dbgs() << "Unhandled opcode: "
+                 << TII->getName(MI->getOpcode()) << "\n");
+    break;
+  }
+
+  return MachineLiveValPtr(Val);*/
+}
+
Index: lib/Target/PowerPC/PowerPC64Values.h
===================================================================
--- lib/Target/PowerPC/PowerPC64Values.h  (nonexistent)
+++ lib/Target/PowerPC/PowerPC64Values.h  (working copy)
@@ -0,0 +1,28 @@
+//===----- PowerPC64TargetValues.cpp - PowerPC64 specific value generator -----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Target/TargetValues.h"
+
+namespace llvm {
+
+class PowerPC64Values final : public TargetValues {
+public:
+  PowerPC64Values() {}
+  virtual MachineLiveValPtr getMachineValue(const MachineInstr *MI) const;
+
+private:
+  void genADDInstructions(const MachineInstr *MI,
+                          MachineGeneratedVal::ValueGenInstList &IL) const;
+  void
+  genBitfieldInstructions(const MachineInstr *MI,
+                          MachineGeneratedVal::ValueGenInstList &IL) const;
+};
+
+}
+
Index: lib/Target/PowerPC/PPCAsmPrinter.cpp
===================================================================
--- lib/Target/PowerPC/PPCAsmPrinter.cpp        (revision 277823)
+++ lib/Target/PowerPC/PPCAsmPrinter.cpp        (working copy)
@@ -36,6 +36,7 @@
 #include "llvm/CodeGen/MachineRegisterInfo.h"
 #include "llvm/CodeGen/StackMaps.h"
 #include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/CodeGen/UnwindInfo.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/DerivedTypes.h"
@@ -70,10 +71,11 @@
     MapVector<MCSymbol*, MCSymbol*> TOC;
     const PPCSubtarget *Subtarget;
     StackMaps SM;
+    UnwindInfo UI;
   public:
     explicit PPCAsmPrinter(TargetMachine &TM,
                            std::unique_ptr<MCStreamer> Streamer)
-        : AsmPrinter(TM, std::move(Streamer)), SM(*this) {}
+        : AsmPrinter(TM, std::move(Streamer)), SM(*this), UI(*this) {}

     const char *getPassName() const override {
       return "PowerPC Assembly Printer";
@@ -101,7 +103,9 @@
     void EmitTlsCall(const MachineInstr *MI, MCSymbolRefExpr::VariantKind VK);
     bool runOnMachineFunction(MachineFunction &MF) override {
       Subtarget = &MF.getSubtarget<PPCSubtarget>();
-      return AsmPrinter::runOnMachineFunction(MF);
+      bool retval = AsmPrinter::runOnMachineFunction(MF);
+      UI.recordUnwindInfo(MF);
+      return retval;
     }
   };

@@ -327,7 +331,9 @@
 }

 void PPCAsmPrinter::EmitEndOfAsmFile(Module &M) {
-  SM.serializeToStackMapSection();
+  UI.serializeToUnwindInfoSection();
+  SM.serializeToStackMapSection(&UI);
+  UI.reset(); // Must reset after SM serialization to clear metadata
 }

 void PPCAsmPrinter::LowerSTACKMAP(MCStreamer &OutStreamer, StackMaps &SM,
Index: lib/Target/PowerPC/PPCSubtarget.h
===================================================================
--- lib/Target/PowerPC/PPCSubtarget.h        (revision 277823)
+++ lib/Target/PowerPC/PPCSubtarget.h        (working copy)
@@ -22,6 +22,7 @@
 #include "llvm/MC/MCInstrItineraries.h"
 #include "llvm/Target/TargetSelectionDAGInfo.h"
 #include "llvm/Target/TargetSubtargetInfo.h"
+#include "PowerPC64Values.h"
 #include <string>
 
 #define GET_SUBTARGETINFO_HEADER
@@ -67,6 +68,7 @@
 protected:
   /// TargetTriple - What processor and OS we're targeting.
   Triple TargetTriple;
+  PowerPC64Values VGen;
 
   /// stackAlignment - The minimum alignment known to hold of the stack frame on
   /// entry to the function and which must be maintained by every function.
@@ -172,6 +174,11 @@
   }
   const PPCTargetMachine &getTargetMachine() const { return TM; }
 
+  const PowerPC64Values *getValues() const override {
+    return &VGen;
+  }
+
+
   /// initializeSubtargetDependencies - Initializes using a CPU and feature string
   /// so that we can use initializer lists for subtarget initialization.
   PPCSubtarget &initializeSubtargetDependencies(StringRef CPU, StringRef FS);
